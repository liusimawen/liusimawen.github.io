---
layout: post
title:  "C#实现经典算法--搜索"
date:   2019-04-28 11:15:19 +0800
categories: jekyll update
---
# 搜索算法
## 广度优先搜索
<li>优先一层一层遍历，每层遍历都以上一层遍历的结果作为起点，遍历一个距离所能访问到的所有节点。遍历过的节点不能再次遍历。</li>
<li>可以求解无权图的最短路径长度。因为第一次遍历到目的节点，其所经过的路径为最短路径。</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
{% highlight c# %}
        private readonly static int[][] grid = new int[][] { new int[]{ 1, 1, 0, 1 },new int[]{ 1, 0, 1, 0 },
            new int[]{ 1, 1, 1, 1},new int[]{ 1, 0, 1, 1},new int[]{ 1, 0, 1, 1} };
        public static int GetShortestPath(int tr,int tc)
        {
            //交错数组，二维数组是int[,]
            int[][] direction = new int[][] { new int[]{ -1, 0 }, new int[] { 1, 0 },
                new int[]{ 0, -1 }, new int[]{ 0, 1 } };
            int m = grid.Length;int n = grid[0].Length;
            int pathLength = 0;
            Queue<KeyValuePair<int, int>> quene = new Queue<KeyValuePair<int, int>>();
            quene.Enqueue(new KeyValuePair<int, int>(0, 0));
            while (quene.Count > 0)
            {
                int size = quene.Count;
                pathLength++;
                while (size-- > 0)
                {
                    KeyValuePair<int, int> cur = quene.Dequeue();
                    int cr = cur.Key;int cc = cur.Value;
                    foreach (int[] d in direction)
                    {
                        int nr = cr + d[0];int nc = cc + d[1];
						//注意nr>=m，等号不能省略
                        if (nr < 0 || nr >= m || nc < 0 || nc >= n || grid[nr][nc] == 0)
                            continue;
                        if (nr == tr && nc == tc)
                            return pathLength;
                        quene.Enqueue(new KeyValuePair<int, int>(nr, nc));
                    }
                }
            }
            return -1;
        }
    }
{% endhighlight %}