---
layout: post
title:  "C#面试知识点"
date:   2019-05-09 17:15:19 +0800
categories: jekyll update
---
# 进程
进程间的通信
<li>Pipeline管道</li>
<li>socket</li>
<li>信号量</li>
<li>共享内存：文件保存到特定内存，一个进程写，一个进程读。</li>
<li>消息队列：和管道相似，但无固定读写进程，可以同时支持多个进程，但只在内存中实现。而管道还可以在磁盘上实现。</li>
## 线程和进程比较
相似：

<li>线程可以看成是轻量级的进程。所以使用了进程之后，再引入线程并不能提高性能。</li>
<li>不同的线程和不同的进程都可以通信。</li>
<li>线程和进程都有优先级，都需要系统进行调度。</li>
<li>线程和进程都有状态。 </li>
不同之处：

<li>线程的任务是虚拟化CPU，令CPU不再是所有进程共享的一个互斥元件，进程的任务则是提高CPU的使用效率。</li>
<li>线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位。同一进程中，线程的切换不会引起进程的切换，
但从一个进程中的线程切换到另外一个进程中的线程时，将会引起进程切换。</li>
<li>一个进程可以包括多个线程，而且至少要有一个前台线程。</li>
<li>进程之间通过虚拟内存隔离，但一个进程中的线程共享所有进程的资源。</li>
# 线程
线程有自己的线程栈，大小为1M，所以它可以维护自己的变量。线程是一个新的对象，会增加系统上下文切换的次数，
所以过多的线程会导致系统开销很大。
## 线程的状态
线程的主要状态有四种：就绪（Unstarted），运行（Running），阻塞（WaitSleepJoin）和停止（Stopped），
还有一种Aborted就是被杀死了。通常，强制获得线程执行任务的结果，或者通过锁等同步工具，会令线程进入阻塞状态。
当得到结果之后，线程就解除阻塞，回到就绪状态。
<li>当线程被阻塞后，它立刻用尽它的时间片，因此不会占用CPU，CPU永远不会调度时间片给它，直到它解除阻塞为止。
主要方式有Thread.Join();Thread.Sleep();Task.Result;Task.Wait();遇到锁，等待其他线程释放锁。</li>
## C# 线程Thread中的方法
Start：使线程从就绪状态进入运行状态

Sleep：使线程从运行状态进入阻塞状态，持续若干时间，然后阻塞自动解除回到运行状态

Join：使线程从运行状态进入阻塞状态，当其他线程都结束时阻塞解除

Interrupt：当线程被阻塞时，即使阻塞解除的要求还没有达到，可以使用Interrupt方法强行唤醒线程使线程进入运行状态。这将会引发一个异常。（例如休息10000秒的线程可以被立刻唤醒）

Abort：使用Abort方法可以强行杀死一个处于任何状态的线程
## 前台和后台线程
使用Thread类创建的线程默认是前台线程。前台线程使得整个进程得以继续下去，当进程中的前台线程终止时，CLR将强制终止该进程的所有后台线程。

## 多线程的好处和坏处
好处：

更大限度的利用CPU和其他计算机资源。
当一条线程冻结时，其他线程仍然可以运行。
在后台执行长任务时，保持用户界面良好的响应。
并行计算（仅当这么做的好处大于对资源的损耗时）
坏处：

线程的创建和维护需要消耗计算机资源。（使用线程池，任务来抵消一部分损失）。一条线程至少需要耗费1M内存。
多个线程之间如果不同步，结果将会难以预料。（使用锁和互斥）
线程的启动和运行时间是不确定的，由系统进行调度，所以可能会造成资源争用，同样造成难以预料的结果。（使用锁和互斥，或者进行原子操作）
为了避免2和3，需要开发者更精细的测试代码，增加了开发时间。

# 多线程概念博文
<a href="https://www.cnblogs.com/haoyifei/p/6855565.html" target="_Blank">线程、线程池、任务要点</a><br>

<li></li>